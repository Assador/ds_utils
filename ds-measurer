#!/usr/bin/perl
#
#  ds-measurer, v1.1, GTK+
#  Copyright © 2016 Dmitry Sokolov
#
#  This file is part of ds-measurer.
#
#  ds-measurer is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  ds-measurer is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with ds-measurer.  If not, see <http://www.gnu.org/licenses/>.
#
#  Скрипт предназначен для измерения области экрана — ширины, высоты, координат
#  начальной и конечной точек измерения, угла и длины отрезка между ними.
#  Процесс происходит в графическом режиме: на отдельном прозрачном слое поверх
#  текущей отрисовки экрана выводятся направляющие линии курсора и выделения
#  и текущие числовые значения. Требуется включённый композитный режим вывода.
#  В процессе измерения есть возможность делать скриншоты выделенной области
#  в буфер обмена и/или файл на диске, сохранять в буфер обмена текущие числовые
#  значения выделения, переключаться в режим выделения из центра, ограничивать
#  выделение каким-либо из заданных соотношений сторон, включать вспомогательные
#  направляющие (центровые, золотого сечения, диагональ), менять их цвета и др.
#  Со скриптом поставляется конфигурационный файл в формате YAML, в котором
#  можно настроить цвета отрисовки, сочетания клавиш для разных функций, набор
#  соотношений сторон фиксации выделения, формат и маску файла скриншота и др.
#  Подробнее: http://sokolov.website/programs/ds-utils/ds-measurer
#
#  Зависимости: perl, libgtk2-perl, libmath-round-perl, libyaml-perl
#
#  Ключей нет; запуск: ds-measurer
#
#  Dmitry Sokolov <dmitry@scrofa-tridens.ru>

use strict;
use warnings;
use utf8;
use open qw/:encoding(UTF-8) :std/;
use Gtk2 "-init";
use POSIX qw(strftime);
use Math::Round;
use YAML;
use File::Basename;
use constant PI => 4 * atan2(1, 1);

my @cpaths = ($ENV{"HOME"} . "/.config/ds-measurer.yaml", dirname(__FILE__) . "/ds-measurer.yaml");
my $config = 0;
foreach(@cpaths) {if(-s && -f) {$config = YAML::LoadFile($_); last;}}
die "No configuration file found at:\n" . join("\n", @cpaths) . "\n" if !$config;
$config->{"screenshot"}->{"file"} =~ s/^~/$ENV{"HOME"}/;

my (@s, $cb, $cr, $state);
my ($sf, $arm) = (0, 1);
my $freeze = $config->{"common"}->{"freeze"} eq "true" ? 1 : 0;
our @g = (0, 1, 0);
our @colors = &set_colors("default");

my $window = Gtk2::Window->new;
$window->signal_connect(destroy => sub {Gtk2->main_quit;});
$window->signal_connect(key_press_event => \&key_press);
$window->signal_connect(key_release_event => \&key_release);
$window->fullscreen;
my $da = Gtk2::DrawingArea->new;
$da->set_events([qw/exposure_mask leave-notify-mask button-press-mask button-release-mask pointer-motion-mask pointer-motion-hint-mask/]);
$da->signal_connect(expose_event => \&expose);
$da->signal_connect(button_press_event => \&button_press);
$da->signal_connect(motion_notify_event => \&motion);
$da->signal_connect(button_release_event => \&button_release);
$window->add($da);
$cb = Gtk2::Clipboard->get(Gtk2::Gdk->SELECTION_CLIPBOARD);
$window->set_colormap($window->get_screen->get_rgba_colormap);
$window->show_all;
$da->window->set_cursor(Gtk2::Gdk::Cursor::new(undef, "blank-cursor"));

my %image = &cscc("image");
my %c = &cscc();
my %w = &cscc();
my $idx = undef;

&cursor();
Gtk2->main;

sub cscc {
	my ($t, $w, $h) = ($_[0] || "recording", $_[1] || $window->get_screen->get_width, $_[2] || $window->get_screen->get_height);
	my ($surface, $context);
	if($t eq "image") {$surface = Cairo::ImageSurface->create("argb32", $w, $h);}
		else {$surface = Cairo::RecordingSurface->create("color-alpha", undef);}
	$context = Cairo::Context->create($surface);
	$context->set_line_width(1);
	$context->save;
	return (surface => $surface, context => $context);
}
sub freeze {
	push @s, {&cscc()};
	$s[$#s]{g} = [@g];
	$s[$#s]{colors} = [@colors];
	&calc($s[$#s], $w{x0}, $w{y0}, $w{x1}, $w{y1});
	&draw($s[$#s]);
}
sub cursor {
	(undef, $c{x1}, $c{y1}, $state) = $da->window->get_pointer;
	$c{context}->set_source_rgba($colors[1][0], $colors[1][1], $colors[1][2], $colors[1][3]);
	$c{context}->move_to($c{x1} + 0.5, 0); $c{context}->line_to($c{x1} + 0.5, $window->get_screen->get_height); $c{context}->stroke;
	$c{context}->move_to(0, $c{y1} + 0.5); $c{context}->line_to($window->get_screen->get_width, $c{y1} + 0.5); $c{context}->stroke;
}
sub clear {
	my @contexts = @_ ? (@_) : (Gtk2::Gdk::Cairo::Context->create($da->window));
	foreach(@contexts) {
		$_->set_operator("clear");
		$_->paint;
		$_->set_operator("over");
		$_->new_path;
	}
	return @contexts;
}
sub screenshot {
	my ($S) = @_;
	my ($xs, $ys, $ws, $hs) = ($$S{x0} < $$S{x1} ? $$S{x0} : $$S{x1} + 1, $$S{y0} < $$S{y1} ? $$S{y0} : $$S{y1} + 1, $$S{w}, $$S{h});
	my $ss = Gtk2::Gdk::Pixbuf->new("rgb", 0, 8, $ws, $hs);
	$ss->get_from_drawable(Gtk2::Gdk->get_default_root_window, Gtk2::Gdk::Colormap->get_system, $xs, $ys, 0, 0, $ws, $hs);
	if($config->{"screenshot"}->{"target"} eq "both"
	|| $config->{"screenshot"}->{"target"} eq "file") {
		eval {$ss->save(strftime($config->{"screenshot"}->{"file"}, localtime), $config->{"screenshot"}->{"format"});}
			or print $@;
	}
	if($config->{"screenshot"}->{"target"} eq "both"
	|| $config->{"screenshot"}->{"target"} eq "clipboard") {
		$cb->set_image($ss);
	}
}
sub set_colors {
	my $ct = shift;
	my @colors = ([$config->{"colors"}->{$ct}->{"main"}->{"r"}, $config->{"colors"}->{$ct}->{"main"}->{"g"}, $config->{"colors"}->{$ct}->{"main"}->{"b"}, $config->{"colors"}->{$ct}->{"main"}->{"a"}], [$config->{"colors"}->{$ct}->{"basic"}->{"r"}, $config->{"colors"}->{$ct}->{"basic"}->{"g"}, $config->{"colors"}->{$ct}->{"basic"}->{"b"}, $config->{"colors"}->{$ct}->{"basic"}->{"a"}], [$config->{"colors"}->{$ct}->{"faded"}->{"r"}, $config->{"colors"}->{$ct}->{"faded"}->{"g"}, $config->{"colors"}->{$ct}->{"faded"}->{"b"}, $config->{"colors"}->{$ct}->{"faded"}->{"a"}], [$config->{"colors"}->{$ct}->{"text main"}->{"r"}, $config->{"colors"}->{$ct}->{"text main"}->{"g"}, $config->{"colors"}->{$ct}->{"text main"}->{"b"}, $config->{"colors"}->{$ct}->{"text main"}->{"a"}], [$config->{"colors"}->{$ct}->{"text basic"}->{"r"}, $config->{"colors"}->{$ct}->{"text basic"}->{"g"}, $config->{"colors"}->{$ct}->{"text basic"}->{"b"}, $config->{"colors"}->{$ct}->{"text basic"}->{"a"}], [$config->{"colors"}->{$ct}->{"text faded"}->{"r"}, $config->{"colors"}->{$ct}->{"text faded"}->{"g"}, $config->{"colors"}->{$ct}->{"text faded"}->{"b"}, $config->{"colors"}->{$ct}->{"text faded"}->{"a"}]);
	return @colors;
}
sub key_n2c {
	return Gtk2::Gdk::Keymap->get_entries_for_keyval(Gtk2::Gdk->keyval_from_name(shift))->{"keycode"};
}
sub calc {
	my ($S, $x0, $y0, $x1, $y1, $state) = @_;
	$$S{x0} = $x0; $$S{y0} = $y0; $$S{x1} = $x1; $$S{y1} = $y1;
	# Выделение из центра
	if($state && $state >= "control-mask") {$$S{x0} = $x0 * 2 - $x1; $$S{y0} = $y0 * 2 - $y1;};
	# Выделение равностороннее
	if($state && $state >= "shift-mask") {
		if(abs $x1 - $x0 >= abs $y1 - $y0) {
			$$S{x1} = $x0 + round($arm * ($x1 - $x0 >= 0 ? (abs $y1 - $y0) : (0 - abs $y1 - $y0)));
			$$S{x0} = $x0 - round($arm * ($x1 - $x0 >= 0 ? (abs $y1 - $y0) : (0 - abs $y1 - $y0))) if $state && $state >= "control-mask";
		} else {
			$$S{y1} = $y0 + round($arm * ($y1 - $y0 >= 0 ? (abs $x1 - $x0) : (0 - abs $x1 - $x0)));
			$$S{y0} = $y0 - round($arm * ($y1 - $y0 >= 0 ? (abs $x1 - $x0) : (0 - abs $x1 - $x0))) if $state && $state >= "control-mask";
		}
	};
	# Расчёт ширины, высоты, длины, угла и значений для прорисовки
	($$S{w}, $$S{h}) = (abs $$S{x1} - $$S{x0}, abs $$S{y1} - $$S{y0});
	($$S{l}, $$S{a}) = (($$S{w} ** 2 + $$S{h} ** 2) ** 0.5, atan2($$S{h}, $$S{w}));
	($$S{xr}, $$S{yr}, $$S{wr}, $$S{hr}) = ($$S{x0} + 0.5, $$S{y0} + 0.5, $$S{x1} - $$S{x0} >= 0 ? ($$S{x1} - $$S{x0} - 1) : ($$S{x1} - $$S{x0} + 1), $$S{y1} - $$S{y0} >= 0 ? ($$S{y1} - $$S{y0} - 1) : ($$S{y1} - $$S{y0} + 1));
	$$S{lr} = round($$S{l}); $$S{ar} = nearest(0.01, $$S{a} * 180 / PI); $$S{ar} =~ s/,/\./;
}
sub draw {
	my $S = $_[0];
	local @g = $_[1] ? @{$_[1]} : @g;
	local @colors = $_[2] ? @{$_[2]} : @colors;
	# Угол
	if($g[0] && $$S{w} > 25) {
		$$S{context}->set_source_rgba($colors[1][0], $colors[1][1], $colors[1][2], $colors[1][3]);
		$$S{context}->arc($$S{xr}, $$S{yr}, 25, 0, $$S{a}) if $$S{x1} - $$S{x0} >= 0 && $$S{y1} - $$S{y0} >= 0;
		$$S{context}->arc($$S{xr}, $$S{yr}, 25, PI * 2 - $$S{a}, 0) if $$S{x1} - $$S{x0} >= 0 && $$S{y1} - $$S{y0} < 0;
		$$S{context}->arc($$S{xr}, $$S{yr}, 25, PI, PI + $$S{a}) if $$S{x1} - $$S{x0} < 0 && $$S{y1} - $$S{y0} < 0;
		$$S{context}->arc($$S{xr}, $$S{yr}, 25, PI - $$S{a}, PI) if $$S{x1} - $$S{x0} < 0 && $$S{y1} - $$S{y0} >= 0;
		$$S{context}->stroke;
	}
	# Координатный прямоугольник
	$$S{context}->set_source_rgba($colors[1][0], $colors[1][1], $colors[1][2], $colors[1][3]);
	$$S{context}->rectangle($$S{xr}, $$S{yr}, $$S{wr}, $$S{hr});
	$$S{context}->stroke;
	# Линии по центру
	if($g[1]) {
		$$S{context}->move_to($$S{xr} + int $$S{wr} / 2, $$S{yr});
		$$S{context}->line_to($$S{xr} + int $$S{wr} / 2, $$S{yr} + $$S{hr});
		$$S{context}->move_to($$S{xr}, $$S{yr} + int $$S{hr} / 2);
		$$S{context}->line_to($$S{xr} + $$S{wr}, $$S{yr} + int $$S{hr} / 2);
		$$S{context}->stroke;
	}
	# Золотое сечение
	if($g[2]) {
		$$S{context}->move_to($$S{xr} + int $$S{wr} * 0.382, $$S{yr});
		$$S{context}->line_to($$S{xr} + int $$S{wr} * 0.382, $$S{yr} + $$S{hr});
		$$S{context}->move_to($$S{xr}, $$S{yr} + int $$S{hr} * 0.382);
		$$S{context}->line_to($$S{xr} + $$S{wr}, $$S{yr} + int $$S{hr} * 0.382);
		$$S{context}->move_to($$S{xr} + int $$S{wr} * 0.618, $$S{yr});
		$$S{context}->line_to($$S{xr} + int $$S{wr} * 0.618, $$S{yr} + $$S{hr});
		$$S{context}->move_to($$S{xr}, $$S{yr} + int $$S{hr} * 0.618);
		$$S{context}->line_to($$S{xr} + $$S{wr}, $$S{yr} + int $$S{hr} * 0.618);
		$$S{context}->stroke;
	}
	# Основной отрезок
	if($g[0]) {
		$$S{context}->set_source_rgba($colors[0][0], $colors[0][1], $colors[0][2], $colors[0][3]);
		$$S{context}->move_to($$S{xr}, $$S{yr});
		$$S{context}->line_to($$S{xr} + $$S{wr}, $$S{yr} + $$S{hr});
		$$S{context}->stroke;
	}
	# Текст
	my ($tt, $te);
	$$S{context}->set_source_rgba($colors[4][0], $colors[4][1], $colors[4][2], $colors[4][3]);
	$$S{context}->select_font_face("sans", "normal", "normal");
	$$S{context}->set_font_size(11);
	my @pp = (3, 4, 5);
	# Текст, ширина
	$tt = $$S{w}; $te = $$S{context}->text_extents($tt);
	$$S{context}->move_to($$S{xr} + $$S{wr} / 2 - $te->{"width"} / 2, $$S{yr} + $$S{hr} - ($$S{y1} - $$S{y0} >= 0 ? (0 - $te->{"height"} - $pp[1]) : $pp[2]));
	$$S{context}->show_text($tt);
	# Текст, высота
	$tt = $$S{h}; $te = $$S{context}->text_extents($tt);
	$$S{context}->move_to($$S{xr} + $$S{wr} + ($$S{x1} - $$S{x0} >= 0 ? $pp[0] : (0 - $te->{"width"} - $pp[1])), $$S{yr} + $$S{hr} / 2 + $te->{"height"} / 2);
	$$S{context}->show_text($tt);
	# Текст, угол
	if($g[0]) {
		$tt = "$$S{ar}°"; $te = $$S{context}->text_extents($tt);
		$$S{context}->move_to($$S{xr} + ($$S{x1} - $$S{x0} >= 0 ? $pp[0] : (0 - $te->{"width"} - $pp[1])), $$S{yr} - ($$S{y1} - $$S{y0} >= 0 ? $pp[2] : (0 - $te->{"height"} - $pp[1])));
		$$S{context}->show_text($tt);
	}
	# Текст, координаты начальные
	$$S{context}->set_source_rgba($colors[5][0], $colors[5][1], $colors[5][2], $colors[5][3]);
	$tt = "($$S{x0}, $$S{y0})"; $te = $$S{context}->text_extents($tt);
	$$S{context}->move_to($$S{xr} + ($$S{x1} - $$S{x0} >= 0 ? (0 - $te->{"width"} - $pp[1]) : $pp[0]), $$S{yr} - ($$S{y1} - $$S{y0} >= 0 ? $pp[2] : (0 - $te->{"height"} - $pp[1])));
	$$S{context}->show_text($tt);
	# Текст, координаты текущие
	$$S{context}->set_source_rgba($colors[3][0], $colors[3][1], $colors[3][2], $colors[3][3]);
	$tt = "($$S{x1}, $$S{y1})"; $te = $$S{context}->text_extents($tt);
	$$S{context}->move_to($$S{xr} + $$S{wr} + ($$S{x1} - $$S{x0} >= 0 ? $pp[0] : (0 - $te->{"width"} - $pp[1])), $$S{yr} + $$S{hr} - ($$S{y1} - $$S{y0} >= 0 ? (0 - $te->{"height"} - $pp[1]) : $pp[2]));
	$$S{context}->show_text($tt);
	# Текст, длина
	if($g[0] && $$S{w} > 55 && $$S{h} > 31) {
		$$S{context}->set_source_rgba($colors[3][0], $colors[3][1], $colors[3][2], $colors[3][3]);
		$tt = "$$S{lr}"; $te = $$S{context}->text_extents($tt);
		$$S{context}->move_to($$S{xr} + $$S{wr} / 2 + ($$S{x1} - $$S{x0} >= 0 ? $pp[0] : (0 - $te->{"width"} - $pp[1])), $$S{yr} + $$S{hr} / 2 - ($$S{y1} - $$S{y0} >= 0 ? $pp[2] : (0 - $te->{"height"} - $pp[1])));
		$$S{context}->show_text($tt);
	}
}
sub expose {
	&clear($image{context});
	foreach(@s, \%c, \%w) {
		$image{context}->set_source_surface($_->{surface}, 0, 0);
		$image{context}->paint;
	}
	($cr) = &clear();
	$cr->set_source_surface($image{surface}, 0, 0);
	$cr->paint;
}
sub motion {
	if(!$sf) {
		my ($widget, $event) = @_;
		if(!defined($event) || $event->type eq "motion-notify" && $event->is_hint || $event->type eq "key-press" || $event->type eq "key-release") {
			&clear($c{context}, $w{context});
			if($state >= "button1-mask") {
				(undef, $c{x1}, $c{y1}, $state) = $widget->window->get_pointer;
				&calc(\%w, $c{x0}, $c{y0}, $c{x1}, $c{y1}, $state);
				# Курсор
				$c{context}->set_source_rgba($colors[1][0], $colors[1][1], $colors[1][2], $colors[1][3]);
				$c{context}->move_to($c{x1} - $c{x0} >= 0 ? ($c{x1} - 0.5) : ($c{x1} + 1.5), 0);
				$c{context}->line_to($c{x1} - $c{x0} >= 0 ? ($c{x1} - 0.5) : ($c{x1} + 1.5), $window->get_screen->get_height);
				$c{context}->stroke;
				$c{context}->move_to(0, $c{y1} - $c{y0} >= 0 ? ($c{y1} - 0.5) : ($c{y1} + 1.5));
				$c{context}->line_to($window->get_screen->get_width, $c{y1} - $c{y0} >= 0 ? ($c{y1} - 0.5) : ($c{y1} + 1.5));
				$c{context}->stroke;
				&draw(\%w);
			} else {
				&cursor();
			}
			$widget->queue_draw;
		}
	}
}
sub button_press {
	my ($widget, $event) = @_;
	if($event->button == 1) {
		($c{x0}, $c{y0}) = $event->coords; $w{x0} = $c{x0}; $w{y0} = $c{y0}; $w{x1} = $c{x1}; $w{y1} = $c{y1};
	}
	if($event->button == 3 && (defined $idx || $state >= "button1-mask")) {
		my $S = defined $idx ? $s[$idx] : \%w;
		$cb->set_text("⤢ $$S{w} ⨯ $$S{h} | 𝄩 $$S{lr} | ⦟ $$S{ar}° | ⇱ ($$S{x0}, $$S{y0}) | ⇲ ($$S{x1}, $$S{y1})");
	}
}
sub button_release {
	my ($widget, $event) = @_;
	if($event->button == 1) {
		&freeze() if $freeze;
		&clear($c{context}, $w{context});
		&cursor();
		$widget->queue_draw;
	}
}
sub key_press {
	my ($widget, $event) = @_;
	# Выделение равностороннее и из центра
	if($event->hardware_keycode == key_n2c($config->{"shortcuts"}->{"fixed ratio"})
	|| $event->hardware_keycode == key_n2c($config->{"shortcuts"}->{"from center"})) {
		&motion;
	}
}
sub highlight {
	my ($i, $widget, $event) = @_;
	if(@s && (defined $i || defined $idx)) {
		if(defined $idx) {
			&clear($s[$idx]{context});
			&draw($s[$idx], $s[$idx]{g}, $s[$idx]{colors});
		}
		$idx = defined $i ? $i % @s : undef;
		if(defined $idx) {
			&clear($s[$idx]{context});
			&draw($s[$idx], $s[$idx]{g}, [&set_colors("highlight")]);
		}
		$widget->queue_draw;
	}
}
sub key_release {
	my ($widget, $event) = @_;
	# Отмена выделения равностороннего и из центра
	if($event->hardware_keycode == key_n2c($config->{"shortcuts"}->{"fixed ratio"})
	|| $event->hardware_keycode == key_n2c($config->{"shortcuts"}->{"from center"})) {
		&motion;
	}
	# Выход
	if($event->hardware_keycode == key_n2c($config->{"shortcuts"}->{"quit"})) {
		exit 0;
	}
	# Текущее выделение
	if($event->hardware_keycode == key_n2c($config->{"shortcuts"}->{"current measure"})) {
		&highlight(undef, @_);
	}
	# Предыдущее выделение
	if($event->hardware_keycode == key_n2c($config->{"shortcuts"}->{"previous measure"})) {
		&highlight(defined $idx ? $idx - 1 : $#s, @_);
	}
	# Следующее выделение
	if($event->hardware_keycode == key_n2c($config->{"shortcuts"}->{"next measure"})) {
		&highlight(defined $idx ? $idx + 1 : 0, @_);
	}
	# Обычный режим
	if($event->hardware_keycode == key_n2c($config->{"shortcuts"}->{"freeze off"})) {
		$freeze = 0;
	}
	# Режим заморозки
	if($event->hardware_keycode == key_n2c($config->{"shortcuts"}->{"freeze on"})) {
		$freeze = 1;
	}
	# Удаление слоя заморозки
	if($event->hardware_keycode == key_n2c($config->{"shortcuts"}->{"freeze clear"})) {
		if(defined $idx) {
			splice @s, $idx, 1;
			$idx = undef;
		}
		$widget->queue_draw;
	}
	# Удаление последнего слоя заморозки
	if($event->hardware_keycode == key_n2c($config->{"shortcuts"}->{"freeze clear last"})) {
		pop @s;
		if(defined $idx && $idx > $#s) {
			$idx = undef;
		}
		$widget->queue_draw;
	}
	# Удаление всех слоёв заморозки
	if($event->hardware_keycode == key_n2c($config->{"shortcuts"}->{"freeze clear all"})) {
		undef @s;
		$idx = undef;
		$widget->queue_draw;
	}
	# Скриншот
	if($event->hardware_keycode == key_n2c($config->{"shortcuts"}->{"screenshot"})
	&& (defined $idx || $state >= "button1-mask")) {
		$sf = 1;
		&clear();
		Glib::Timeout->add(100, sub {
			&screenshot(defined $idx ? $s[$idx] : \%w);
			$sf = 0;
			$widget->queue_draw;
		});
	}
	# Основной отрезок
	if($event->hardware_keycode == key_n2c($config->{"shortcuts"}->{"segment line"})) {
		$g[0] = !$g[0];
		&motion;
	}
	# Линии по центру
	if($event->hardware_keycode == key_n2c($config->{"shortcuts"}->{"center lines"})) {
		$g[1] = !$g[1];
		&motion;
	}
	# Золотое сечение
	if($event->hardware_keycode == key_n2c($config->{"shortcuts"}->{"golden sections"})) {
		$g[2] = !$g[2];
		&motion;
	}
	# Цветовые схемы
	while(my ($key, $value) = each %{$config->{"colors shortcuts"}}) {
		if($event->hardware_keycode == key_n2c($value)) {
			@colors = &set_colors($key);
			&motion;
		}
	}
	# Соотношение сторон
	while(my ($key, $value) = each %{$config->{"aspect ratio shortcuts"}}) {
		if($event->hardware_keycode == key_n2c($value)) {
			$arm = eval($key);
			&motion;
		}
	}
}
exit 0;
